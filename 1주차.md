# 1주차

* JVM이란 무엇인가
* 컴파일 하는 방법
* 실행하는 방법
* 바이트코드란 무엇인가
* JIT 컴파일러란 무엇이며 어떻게 동작하는지
* JVM 구성 요소
* JDK와 JRE의 차이

### JVM이란 무엇인가
> Java Virtual Machine(자바 가상 기계)의 줄임말이다. 역할은 자바 바이트 코드를 os에 맞게 해석해 주는 역할을 한다. 프로그램이 실행되면, jvm은 os로부터 이 프로그램이 필요로하는 메모리를 할당받고, jvm은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 바이트 코드는  기계어가 아니기 떄문에 os에서 바로 실행되지 않는데, 그떄  jvm은 os가 바이트코드를 이해할 수 있도록 해석해 준다. 하지만 jvm의 해석을 거치기 때문에 c언어 같은 네이티브 언어에 비해 속도가 느렸지만 jit컴파일러를 구현해 이점을 극복했다.
> os에 종속적이지 얺고 java파일 하나만 만들면 어느 디바이스든 jvm 위에서 실행 할 수 있다.

### 컴파일 하는 방법
> 컴파일이란? 소스코드를 컴퓨터가 이해할 수 있는 기계어 구조로 변환하는 과정
> 컴파일되어 실행되기까지의 순서
> 1. 소스코드를 작성 .java
> 2. 작성한 소스코드를 컴파일 .class
> 3. 프로그램 실행에 필요한 .class 파일들을 모두 읽어 연결
> 4. 프로그램 실행 전 메모리 초기화 작업 진행
> 5. 바이트 코드로 작성된 프로그램을 인터프리터가 기계어로 번역하여 실행

> 컴파일을 위해선 javac와 java 가 필요
> javac는 자바 소스코드를 컴파일 할떄 사용하는 프로그램 
> java는 컴파일된 바이트 코드를 실행

> 방법  
> 자바 소스 파일 작성 .java  
> Java.exe를 사용하여 .java 파일 컴파일  
> Javac 소스코드파일명.java -> 소스파일명.class 생성됨  

### 실행하는 방법  
> Java.exe파일을 사용하여 바이트 코드로 컴파일 된 .class 실행  
> Java 소스파일명  

### 바이트코드란 무엇인가
> 특정 하드웨어가 아닌 가상 머신에서 돌아가는 실행프로그램을 위한 이진 표현법이다.  
> 하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에, 보통 기계어보다 더 추상적이다.  
> 여기서 헷갈리는것들을 정리하자  

> ##### 바이너리 코드: 바이너리 코드는 컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드를 의미  
> ##### 기계어:  
> -기계어는 바이너리 코드이다.  
> -기계어는 이진코드로 이루어져 있을 뿐이지 모든 이진코드가 기계어는 아니다  
> (모든 바이너리코드 != 기계어)  
> -기계어는 특정한 언어가 아니다 단지 cpu제조사에서 cpu를 만들 때 해당 cpu에서 사용하는 명령어 집합을 공개하는데, 이것을 기계어라고 부를뿐.. 때문에 제조사에 따라 기계어가 변경된다 . 같은 동작이지만 완전히 다른 0과 1의 나열이 될 수 있다.  
> -아주 기존적인 연산자들은 서로 호환이 되는 편  
> ##### 바이트 코드: cpu가 이해할 수 있는 언어가 바이너리 코드라면 바이트 코드는 가상 머신이 이해 할 수 있는 언어,  
> cpu가 아닌 가상 머신에서 이해 할 수 있는 코드를 위한 이진 표현법, 즉 가상머신이 이해 할 수 있는 0과 1로 구성된 이 진코드 -> 어떤 플렛폼에도 종속되지 않고 실행 가능  
> 고급언어로 작성된 소스코드를 가상머신이 이해할 수 있는 중간코드로 컴파일한 것을 말한다.  
> 바이트 코드는 실시간 번역기또는 jit컴파일러에 의해 바이너리 코드로 변환된다.  
> jvm을 위한 바이트 코드를 자바 바이트 코드라고 한다.  

### JIT 컴파일러란 무엇이며 어떻게 동작하는지
> Jit 컴파일(just in time)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법.  
> 전통적인 컴퓨터 프로그램을 만드는 방법 2가지 1) 인터프리트방식 2) 정적 컴파일 방식  
> 1. 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행  
> 2. 실행하기 전에 프로그램코드를 기계어로 번역  
> jit컴파일러는 두가지의 방식을 혼합한 방식  
> -실행한 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐시에 저장,  
> 같은 함수가 여러 번 불릴 댸 매법 기계어 코드를 생성하는 것을 방지  
> Jit(just in time)는 바이트코드를 프로그램이 실제 실행하는 시점에 각 os맞는 네이티브 코드로 바꿔서 실행,  
> 빠르지만 역시 변환하는데 비용이 발생한다. 이 같은 이유 때문에 jvm은 모든 코드를 jit compiler 방식으로 실행하지 않고  
> 인터프리티 방식을 사용하다 일정한 기준이 넘어가면 jit compiler방식으로 실행한다.  

### JVM 구성 요소  
> ##### Class Loader로 jvm 내로 .class파일을 로드하고 링크를 통해 Runtime Data Areas에 적재하고 Execution Engine로 클래스를 실행시킨다.  
  ![jvm](https://user-images.githubusercontent.com/60220562/99228786-72882b80-2830-11eb-82a8-aacc306f706c.png)  
  ![image](https://user-images.githubusercontent.com/60220562/99229445-6355ad80-2831-11eb-8211-b2f415810620.png)  
  https://asfirstalways.tistory.com/158



> #### Class Loader  
> 런타임 중에 클래스 파일이 처음로 참조 되었을 때 내부적으로 로딩,링킹,이닛얼라이션 이라는 세가지 단계를 거쳐 jvm 메모리에 적재한다.  
>> 로딩  
>>> - 클래스들은 이 과정에서 로딩된다. 로딩하기 위해 3가지 로더를 이용  
>>> (부트스트랩,익스텐션,어플리케이션)클래스 로더를 사용  
>> 링킹  
>>> 세가지 과정(버리프,프리페어,리졸브)  

>>> -바이트 코드가 적절하게 포맷하여 생성됬는지 검증  
>>> -클래스변수들을 위해 jvm메모리를 할당하고 해당 메모리를 디폴트 벨류로 초기화  
>>> -모든 Symbolic memory references를 Method Area의 Direct references로 대체  
>> 이닛얼라이션  
>>> -초기화 과정으로 클래스로더 서브시스템의 마지막 단계로 코드와 스타틱 블록에 정의되어있는 모든 정적 변수를 할당한다.  
>>> -클래스 로더 시스템은 컴파일된 바이트코드들을 읽어 연결한 뒤 메모리에 저장하는 역할을 수행  
>>> -클래스 로더 시스템 초기화 단계에서 전역변수를 메모리에 할당하기 때문에 남용할 경우 메모리 이슈  
>>> *런타임: 프로그램이 실행되는 시간  

> #### Runtime Data Areas  
>> JVM이 프로그램을 수행하기 위해 os로부터 별도로 할당 받은 메모리 공간을 말하며, 크게 5가지 영역으로 나눌 수 있다. 
>> ##### -Class Area  
>> 메소드영역이라고도 부른다. jvm하나당 하나의 공간, 모든 쓰레드가 공유하는 메모리 영역이다. 클래스, 인터페이스, 메소드, 필드, static변수등의 바이트 코드 등을 보관.  
>> ##### -Stack Area  
>> LIFO구조, 메소드 호출 시마다 각각의 스택프레임(그 메서드만을 위한 공간)이 생성, 메서드 안에서 사용되어지는 값들 저장,  
>> 호출된 메서드의 매개변수, 지역변수, 리턴값 및 연산시 일어나는 값들을 임시로 저장, 메서드 수행이 끝나면 프레임별로 삭제  
>> ##### -Heap Area  
>> jvm하나당 하나의 공간,  
>> New 연산자로 생성된 객체와 배열을 저장하는 공간, 클래스 영역에 로드된 클래스만 생성가능, Garbage Collector를 통해 메모리 반환  
>> 3가지로 나눠져 있다.  
>>> 1. Permanent Generation  
>>> --생성된 객체들의 정보의 주소 값이 저장된 공간  
>>> 2. New Area  
>>> --Eden: 객체들이 최초로 생성되는 공간  
>>> --Survivor: Eden에서 참조되는 객체들이 저장되는 공간  
>>> 3. Old Area  
>>> --new Area에서 일정시간이상 참조되고 있는 객체들이 저장되는 공간  

>> ##### -Native method stack area  
>> 자바 외의 다른 언어에서 제공되는 메서드들이 저장되는 공간  

>> ##### -PC Register  
>> Thread가 생성 될 때마다 생성되는 공간, Thread가 어떤 부분을 어떤 명령으로 실행할 지에 대한 기록, 현재 실행되는 부분의 명령과 주소를 저장  

> #### Execution Engine  
>> 클래스로더에 의해 jvm으로 로드된 클래스의 바이트코드를 실행하는 런타임 모듈이다.   
>> 클래스 로더를 통해 jvm 내의 런타임 데이터 에어리어에 배치된 바이트코드는 execution engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.  
>> 두 가지 방식을 혼합하여 사용한다.  
>> 1. interpreter 방식  
>> 바이트 코드를 한줄씩 해석 속도가 느림  
>> 2. jit방식  
>> 구성요소 3가지중 마지막은 garbage collector  
>> 참조 되었던 객체들을 수집하고 제거하는 역할  

### JDK와 JRE의 차이  
> JRE(Java Runtime Enviroment) : 컴파일된 자바 프로그램을 실행시킬 수 있는 자바 환경  
> JDK(Java Development Kit) : 자바 프로그래밍시 필요한 컴파일러 등을 포함,개발을 위해 필용한 도구 (javac,java등을 포함)  
  ![jdk](https://user-images.githubusercontent.com/60220562/99228764-656b3c80-2830-11eb-9eb6-b58a15ded3a3.png)


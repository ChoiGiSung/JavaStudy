* 제네릭 사용법
* 제네릭 주요 개념 (바운디드 타입, 와일드 카드)
* 제네릭 메소드 만들기
* Erasure


## 왜 제네릭을 사용해야 하는가?

1. 제네릭 타입을 이용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다.
2. 타입 변환을 제거한다.
   비 제네릭 코드는 불필요한 타입변환을 하기에 성능에 악영향을 미친다.
   
         List list = new ArrayList();
         list.add("aa");
         String str=(String)list.get(0);
         ======================================================
         List<String> list = new ArrayList<String>();
         list.add("aa");
         String str=list.get(0);

밑에 처럼 제네릭 코드로 수정하면 list에 저장되는 것은 String타입으로 제한하기에 타입변환을 할 필요가 없다.

## 제네릭 타입 ( class<T>, interface<T> )

제네릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스를 말한다.  
제네릭 타입은 클래스 또는 인터페이스 이름 뒤에 "<>" 부호가 붙고, 사이에 타입이 들어온다.

      pulbic class 클래스이름<T>{...}
      pulbic class 인터페이스이름<T>{...}

제네릭 타입을 실제 코드에서 사용하려면 타입 파라미터에 구체적인 타입을 지정해야한다.  

![img](https://user-images.githubusercontent.com/60220562/109416824-d7dce280-7a03-11eb-93ac-ffde27ea2bd4.png)  
object를 리턴 타입으로 지정하면 set을 할때는 쉽게 사용이 가능하지만  
get을 할때는 사용할 때 마다 타입캐스팅을 해줘야한다. -> 성능저하  

이런 문제를 해결하기 위해 제네릭을 사용한다.  
![img_1](https://user-images.githubusercontent.com/60220562/109416831-df03f080-7a03-11eb-88e9-dbac33443e0f.png)  
이러면 내부적으로는 이렇게 동작한다.  

      public class Box<String>{
         private String t;
         public void set(String t){this.t=t}
         public String get(){return t;}
      }

이렇게 클래스를 설계할 때 타입을 명시하지 않고, 타입 파라미터로 대체했다가 실제 클래스가 사용될 떄 구체적인 타입을 지정해서  
타입 변환을 최소화 시킨다.  


## 멀티 타입 파라미터( class<K,V,...>, interface<K,N,...> )
제네릭 타입은 두 개 이상의 멀티 타입 파라미터를 사용할 수 있다.
![img_3](https://user-images.githubusercontent.com/60220562/109416835-e5926800-7a03-11eb-82b4-ad174bef8b08.png)  

## 제네릭 메소드 ( <T,R> R method (T t) )
제네릭 메소드는 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드를 말한다.  
**선언하는 방법은 리턴 타입 앞에 <> 기호를 추가하고 타입 파라미터를 기술한 다음, 리턴 타입과 매개 타입으로 타입 파라미터를 사용하면 된다.**   

      public <타입 파라미터,...> 리턴타입 메소드명(매개변수,...) {...}
      public <T> Box<T> boxing(T t) {...}

제네릭 메소드는 두 가지 방식으로 호출할 수 있다. 코드에서 타입 파라미터를 구체적으로 명시해도 되고,  
컴파일러가 매개값의 타입을 보고 구체적인 타입을 추정하도록 할 수 있다.  

      리턴타입 변수 = <구체적타입> 메소드명 (매개값);
      리턴타입 변수 = 메소드명 (매개값);

      Box<Integer> box = <Integer>boxing(100);
      Box<Integer> box = boxing(100);


![img_4](https://user-images.githubusercontent.com/60220562/109416840-ecb97600-7a03-11eb-9cd7-6e480dfc03f7.png)  

## 제한된 타입 파라미터 ( <T extends 최상위타입> )

타입 파라미터에 지정되는 구체적인 타입을 제한할 필요가 종종있다.  
숫자 타입만 받고 싶을 때 라던지..  
이럴 때는 타입 파라미터 뒤에 extends 키워드를 붙이고 상위 타입을 명시하면 된다.  
클래스 뿐 아니라 인터페이스도 가능 하다.

      public <T extends 상위타입> 리턴타입 메소드 (매개변수,...) {...}

메소드 사용은 본인(상위) 꺼만 사용가능
다음은 숫자타입만 가지는 제네릭 메소드 compare()다

      public <T extends Number> int compare(T t1,T t2){
         double v1 = t1.doubleValue();
         double v2 = t2.doubleValue();
         return Double.compare(v1,v2);
      }

## 와일드카드 타입 ( <?>, <? extends ...>, <? super ...> )

코드에서 ?를 와일드카드라고 부른다.  
* 제네릭타입<?> : 모든 인터페이스나 모든 클래스
* 제네릭타입<? extends 상위타입> : 본인이나 본인의 자식들이 올 수 이다.
* 제네릭타입<? super 하위타입> : 본인이나 본인 위의 부모들이 올 수 있다.

![img_5](https://user-images.githubusercontent.com/60220562/109416845-f3e08400-7a03-11eb-9d67-eeb95c6804e1.png)  
* Course<?> : 수강생은 모든 타입이 될 수 있다.
* Course<? extends Student> : 수강생은 student와 highStudent만 될 수 있다.
* Course<? super Worker> : 수강생은 worker와 student만 될 수 있다.  

![img_7](https://user-images.githubusercontent.com/60220562/109416847-f642de00-7a03-11eb-9c40-7d7f2fd3394b.png)  
![img_8](https://user-images.githubusercontent.com/60220562/109416849-f7740b00-7a03-11eb-9767-56dfda43e030.png)  

## 제네릭 타입의 상속과 구현

course를 상속받을 수 도있다.

      public class ChildCourse<T,M> extends Course<T>{...}
      //타입 파라미터를 더 늘릴 수 도 있다.
      public class ChildCourse<T,M,C> extends Course<T>{...}

## Erasure

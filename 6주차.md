* 자바 상속의 특징
* super 키워드
* 메소드 오버라이딩
* 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
* 추상 클래스
* final 키워드
* Object 클래스

### 자바 상속의 특징
> #### 상속이란?  
> 부모 클랫의 변수 / 메소드를 자식 클래스가 물려받아 사용하는 것  
> 여기서 부모는 superclass, 자식은 subclass라고 한다.  
> 
> #### 상속의 이유  
> 1. 공통된 특징을 가지는 클래스 사이의 멤버(필드, 메소드) 선언이 불필요하다.  
> 2. 부모 클래스의 멤버를 재사용함으로써 자식 클래스가 간결해진다.  
> 3. 클래스간 계층적 분류 및 관리가 쉬워진다.  
> #### 상속의 특징   
> 1. 자바에서는 다중상속을 지원하지 않는다. 따라서 extends 뒤에는 단 하나의 부모 클래스  
> 만 올 수 있다.  
> 2. 자바에서 최상위 클래스는 object클래스이다. 
> 3. 부모 클래스가 변경되면 자식클래스는 영향을 받지만 , 자식이 변하면 부모는 영향을 받지 않는다.  


    public class car {
    private String modelName;
    private String modelYear;

    public void brake(int price){
        System.out.println(modelName+"브레이크 밟기"+"가격은 "+price);
    }
    }

    public class ToyCar extends car{
    @Override
    public void brake() {
        System.out.println("꼬마자동차 붕붕붕");
    }
    }
> #### 포함 관계  
> 상속이외에도 클래스를 재사용하는 또 다른 방법  
> 한 클래스의 멤버 변수로 다른 클래스를 선언 하는것  
 
    public class MiniCar {
    String modelName;
    car car=new car();
    }   
> 하나의 거대한 클래스를 작성 < 단위별로 여러개의 클래스를 만들고 포함관계로 재사용  
> ##### 그렇담 언제 상속관계를 만들고 언제 포함관계를 만드는게 좋을까?  
> #### 클래스 간의 관계 설정하기
> 쉽게 "~은 ~ 이다"(is-a)와 "~은 ~을 가지고 있다"(has-a) 문장에 대입하자  
> **클래스를 가지고 문장을 만들었을떄 is-a관계이면 상속을 has-a관계이면 포함관계를 사용하자**   

### super 키워드
> **자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.**  
> 모든 객체는 클래스의 생성자를 호출해야만 생성된다.  
> 부모 생성자 또한, 예외는 아니다. **부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.**  
> 명시적으로 선언되지 않았다면, 컴파일러는 아래와 같은 코드를 추가 시킨다.  

    public class car {}
    public class ToyCar extends car{
        public ToyCar(){
            super();
        }
    }
> 첫 줄에 super();가 추가됬다. super는 부모의 기본 생성자를 호출한다.  
> 직접 정의된 생성자를 호출하고 싶으면 그에 맞는 매개값을 전달하며 호출하면 된다.  
> super(매개값1,매개값2,...);  
> 부모 생성자 호출은 무조건 자식 생성자 첫 줄에 위치해야 한다는 것을 명심하자.  

    public class car {
        String modelName;
        String modelYear;

        public car() {
            //this("스포츠카","1955"); // 다른 생성자 호출
        }   
        public car(String modelName, String modelYear) {
            this.modelName = modelName;
            this.modelYear = modelYear;
        }
    }

    public class ToyCar extends car{
        public ToyCar(String modelName, String modelYear, String type) {
            super(modelName, modelYear);
            this.type = type;
        }
    }
    
    public class Main {

        public static void main(String[] args) {
            ToyCar car=new ToyCar("topCar","2015","toy");
            System.out.println(car.modelName); //topCar
            System.out.println(car.modelYear); // 2015
        }
    }
> toy카를 생설할때 모델이름,년도,타입을 파라미터로 줘서 생성하고,  
> toyCar생성자 내부에서는 super를 통해 car의 생성자를 호출한다. 부모의 기본생성자 말고  
> 다른 생성자를 호출하기 위해 파라미터를 줬다.  

### 메소드 오버라이딩
> #### 메소드 오버라이딩  
> 상속 관계에 있는 부모 클래스에 이미 정의된 메소드를 자식 클래스에서 재정의 하는것  
> #### 오버라이딩의 조건
> 1. 메소드의 선언부는 기존 메소드와 같아야한다.  
> 2. 접근 제어자를 더 좁은 범위로 변경x  
> 3. 재정의 전의 범위보다 더 큰 범위의 예외를 선언할 수 없다.  
 
    public class car {
         String modelName;
         String modelYear;

        public void brake(){
            System.out.println(modelName+"브레이크 밟기");
        }
    }
    public class ToyCar extends car{
        String type;
        @Override //오버 라이딩 해서 재 정의 했다.
        public void brake() {
            System.out.println("꼬마자동차 붕붕붕");
        }
        public void fusion(){
            System.out.println("장난감 퓨전");
        }
    }
> #### 다형성을 알아보자
> 다형성이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미  
> 자바에서는 부모클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현  
    
    public class Main {
        public static void main(String[] args) {
            car car = new car();
    
            car.brake();
    
            ToyCar toyCar = new ToyCar();
    
            toyCar.brake();// 오버라이딩된 자식꺼 호출
    
            car bbang = new ToyCar(); //자동 타입변환이라 생각하자
            toyCar.brake(); //자식꺼 호출
            bbang.fusion(); // 찾을 수 없다.
        }
    }
![image](https://user-images.githubusercontent.com/60220562/102761991-02cf0880-43bb-11eb-9743-25aae7b36702.png)

> 부모 타입으로 참조 변수로 자식 클래스 타입의 인스턴스를 참조가능하다.  
> 참조 변수가 사용할 수 있는 멤버의 수가 실제 인스턴스의 멤버 개수보다 적기 때문  
> 반대의 경우 -> ToyCar car=new car(); 는 오류가 난다.  
> 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문  
> **자식의 고유기능을 다시 쓰려면 ((ToyCar)cp).fusion(); 이렇게 2번 싸야한다.**
다이나믹 메소드 디스패치 (Dynamic Method Dispatch)

### 추상 클래스
> #### 추상클래스란?
> 클래스 간에 공통된 특성(필드와 메서드)을 추출한것, 상속만을 위한 클래스  
> 부모 역할이 가능하지만 단독으로 객체생성은 x  
> 모든 추상 클래스, 메소드,변수 는 public  
> #### 왜 사용?
> 1. 공통된 필드와 메서드를 통일할 목적  
> 2. 실체클래스 구현시, 시간절약  
> 3. 규격에 맞는 실체클래스 구현  

    //추상 메소드
    public abstract class Car {
        public String modelName; 
                                
        public void brake(){
            System.out.println("브레이크 밟다");
        }
    
        //추상 메서드
        public abstract void sidong();
        //자손 너네들은 무조건 이거 재정의해
    }

    //상속 받는 MinoCar와 ToyCar
    public class MiniCar extends Car{

        public MiniCar(String ModelName) {
            this.modelName=ModelName;
        }
    
        @Override
        public void sidong() {
            System.out.println(this.modelName+"스마트키 사용");
        }
    }

    public class ToyCar extends Car{

        public ToyCar(String modelName) {
            this.modelName=modelName;
        }
    
        @Override
        public void sidong() {
            System.out.println(this.modelName+"차키 사용");
        }
    }


    public class Main {

        public static void main(String[] args) {
            MiniCarAbstract miniCar=new MiniCarAbstract("미니카 ");
            miniCar.sidong();
            //미니카 스마트키 사용

            ToyCarAbstract toyCar=new ToyCarAbstract("장난감차 ");
            toyCar.sidong();
            //장난감차 차키 사용
    }
> public abstract void sidong(); 는 추상 class에 있는 추상 메소드이다.  
> 추상 class를 상속받은 자식클래스는 반드시 재정의 해야하는 의무를 가지고 있다.  

### final 키워드
### Object 클래스

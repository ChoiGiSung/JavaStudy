* 자바 상속의 특징
* super 키워드
* 메소드 오버라이딩
* 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
* 추상 클래스
* final 키워드
* Object 클래스

### 자바 상속의 특징
> #### 상속이란?  
> 부모 클랫의 변수 / 메소드를 자식 클래스가 물려받아 사용하는 것  
> 여기서 부모는 superclass, 자식은 subclass라고 한다.  
> 
> #### 상속의 이유  
> 1. 공통된 특징을 가지는 클래스 사이의 멤버(필드, 메소드) 선언이 불필요하다.  
> 2. 부모 클래스의 멤버를 재사용함으로써 자식 클래스가 간결해진다.  
> 3. 클래스간 계층적 분류 및 관리가 쉬워진다.  
> #### 상속의 특징   
> 1. 자바에서는 다중상속을 지원하지 않는다. 따라서 extends 뒤에는 단 하나의 부모 클래스  
> 만 올 수 있다.  
> 2. 자바에서 최상위 클래스는 object클래스이다. 
> 3. 부모 클래스가 변경되면 자식클래스는 영향을 받지만 , 자식이 변하면 부모는 영향을 받지 않는다.  


    public class car {
    private String modelName;
    private String modelYear;

    public void brake(int price){
        System.out.println(modelName+"브레이크 밟기"+"가격은 "+price);
    }
    }

    public class ToyCar extends car{
    @Override
    public void brake() {
        System.out.println("꼬마자동차 붕붕붕");
    }
    }
> #### 포함 관계  
> 상속이외에도 클래스를 재사용하는 또 다른 방법  
> 한 클래스의 멤버 변수로 다른 클래스를 선언 하는것  
 
    public class MiniCar {
    String modelName;
    car car=new car();
    }   
> 하나의 거대한 클래스를 작성 < 단위별로 여러개의 클래스를 만들고 포함관계로 재사용  
> ##### 그렇담 언제 상속관계를 만들고 언제 포함관계를 만드는게 좋을까?  
> #### 클래스 간의 관계 설정하기
> 쉽게 "~은 ~ 이다"(is-a)와 "~은 ~을 가지고 있다"(has-a) 문장에 대입하자  
> **클래스를 가지고 문장을 만들었을떄 is-a관계이면 상속을 has-a관계이면 포함관계를 사용하자**   

### super 키워드
> **자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.**  
> 모든 객체는 클래스의 생성자를 호출해야만 생성된다.  
> 부모 생성자 또한, 예외는 아니다. **부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.**  
> 명시적으로 선언되지 않았다면, 컴파일러는 아래와 같은 코드를 추가 시킨다.  

    public class car {}
    public class ToyCar extends car{
        public ToyCar(){
            super();
        }
    }
> 첫 줄에 super();가 추가됬다. super는 부모의 기본 생성자를 호출한다.  
> 직접 정의된 생성자를 호출하고 싶으면 그에 맞는 매개값을 전달하며 호출하면 된다.  
> super(매개값1,매개값2,...);  
> 부모 생성자 호출은 무조건 자식 생성자 첫 줄에 위치해야 한다는 것을 명심하자.  

    public class car {
        String modelName;
        String modelYear;

        public car() {
            //this("스포츠카","1955"); // 다른 생성자 호출
        }   
        public car(String modelName, String modelYear) {
            this.modelName = modelName;
            this.modelYear = modelYear;
        }
    }

    public class ToyCar extends car{
        public ToyCar(String modelName, String modelYear, String type) {
            super(modelName, modelYear);
            this.type = type;
        }
    }
    
    public class Main {

        public static void main(String[] args) {
            ToyCar car=new ToyCar("topCar","2015","toy");
            System.out.println(car.modelName); //topCar
            System.out.println(car.modelYear); // 2015
        }
    }
> toy카를 생설할때 모델이름,년도,타입을 파라미터로 줘서 생성하고,  
> toyCar생성자 내부에서는 super를 통해 car의 생성자를 호출한다. 부모의 기본생성자 말고  
> 다른 생성자를 호출하기 위해 파라미터를 줬다.  
### 메소드 오버라이딩
